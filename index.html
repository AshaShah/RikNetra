<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rigveda Connections</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="search-container">
    <label for="chapter-input">Search Chapter:</label>
    <input type="text" id="chapter-input" placeholder="Search for a chapter">
    <div id="autocomplete-results" class="autocomplete-results"></div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <!-- Fixed-size container for the graph -->
  <div class="graph-container">
    <!-- Zoom controls -->
    <div class="zoom-controls">
      <button id="zoom-in">+</button>
      <button id="zoom-out">-</button>
    </div>
    <!-- SVG container -->
    <div class="svg-container">
      <svg></svg>
    </div>
  </div>

  <script>
    d3.json("updated_data.json").then(function (data) {
      const width = 800; // Fixed width for the container
      const height = 800; // Fixed height for the container

      // Create an SVG element and append it to the container
      // Create an SVG element and append it to the container
      const svg = d3.select(".svg-container")
        .append("svg")
        .attr("width", "100%") // Fixed width for the container
        .attr("height", "100%") // Fixed height for the container
        .attr("viewBox", [0, 0, width, height]) // Set viewBox to enable scaling
        .attr("preserveAspectRatio", "xMidYMid meet") // Maintain aspect ratio
        .call(d3.zoom()
          .scaleExtent([0.2, 5]) // Set minimum and maximum zoom levels
          .on("zoom", (event) => {
            g.attr("transform", event.transform); // Apply zoom transformation to the group
          })
        );

      // Append a group element to the SVG for zooming
      const g = svg.append("g");

      // Define zoom behavior for the SVG
      const zoom = d3.zoom()
        .scaleExtent([0.2, 5])
        .on("zoom", (event) => {
          g.attr("transform", event.transform);
        });


      // Select the tooltip element
      const tooltip = d3.select("#tooltip");

      // Create a force simulation with nodes and edges
      const simulation = d3.forceSimulation(data.nodes)
        .force("link", d3.forceLink(data.edges).id(d => d.id).distance(150)) // Link force
        .force("charge", d3.forceManyBody().strength(-300)) // Repulsion force
        .force("center", d3.forceCenter(width / 2, height / 2)) // Center force
        .force("x", d3.forceX(width / 2).strength(0.1)) // Pull nodes toward the center horizontally
        .force("y", d3.forceY(height / 2).strength(0.1)); // Pull nodes toward the center vertically


      // Create lines for each edge in the data
      const link = g.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(data.edges)
        .enter()
        .append("line")
        .attr("stroke", "#aaa") // Set the stroke color
        .attr("stroke-width", d => 10 - d.weight * 5); // Adjust thickness (less weight = wider)

      // Create nodes for each node in the data
      const node = g.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(data.nodes)
        .enter()
        .append("g")
        .attr("class", "node")
        .call(d3.drag() // Enable drag behavior for nodes
          .on("start", dragStarted)
          .on("drag", dragged)
          .on("end", dragEnded));

      // Append circles to each node
      node.append("circle")
        .attr("r", 20) // Set the radius of the circle
        .attr("fill", "#69b3a2") // Set the fill color
        .on("mouseover", (event, d) => {
          // Show tooltip and highlight node and connected links on mouseover
          if (!selectedNode) {
            tooltip.style("display", "block").html(`<strong>${d.name}</strong>`);
            d3.select(event.target).attr("fill", "#ff6f61");
            link.filter(l => l.source === d || l.target === d)
              .attr("stroke", "#ff6f61").attr("stroke-width", d => d.weight * 1000 + 2);
          }
        })
        .on("mousemove", (event) => {
          // Move the tooltip with the mouse
          if (!selectedNode) {
            tooltip.style("top", `${event.pageY + 10}px`).style("left", `${event.pageX + 10}px`);
          }
        })
        .on("mouseout", (event, d) => {
          // Hide tooltip and reset styles on mouseout
          if (!selectedNode) {
            tooltip.style("display", "none");
            d3.select(event.target).attr("fill", "#69b3a2");
            link.attr("stroke", "#aaa").attr("stroke-width", d => d.weight * 1000);
          }
        })
        .on("click", (event, d) => {
          // Set the selected node and navigate to its URL if available
          setSelectedNode(d, event.target);
        });

      // Append text labels to each node
      node.append("text")
        .attr("dy", 4) // Adjust the vertical position of the text
        .attr("x", 25) // Adjust the horizontal position of the text
        .text(d => d.name); // Set the text content to the node's name

      // Update the positions of links and nodes on each tick of the simulation
      simulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node.attr("transform", d => `translate(${d.x},${d.y})`);
      });

      // Variables to keep track of the selected node and its circle element
      let selectedNode = null;
      let selectedCircle = null;

      // Function to set the selected node and highlight it
      function setSelectedNode(nodeData, circleElement) {
        selectedNode = nodeData;
        selectedCircle = circleElement;
        highlightSelectedNode();
      }

      // Function to highlight the selected node and its connected links
      function highlightSelectedNode() {
        node.selectAll("circle")
          .attr("fill", d => (d === selectedNode ? "#ff6f61" : "#ccc"));

        node.selectAll("text")
          .attr("fill", d => (d === selectedNode ? "#ff6f61" : "#ccc"));

        link.attr("stroke", d => (d.source === selectedNode || d.target === selectedNode ? "#ff6f61" : "#ccc"))
            .attr("stroke-width", d => (d.source === selectedNode || d.target === selectedNode ? d.weight * 1000 + 2 : d.weight * 1000));
      }

      // Drag event handlers for nodes
      function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      // Select the chapter input and autocomplete results elements
      const chapterInput = d3.select("#chapter-input");
      const autocompleteResults = d3.select("#autocomplete-results");

      // Listen for input events on the chapter input field
      chapterInput.on("input", function() {
        const searchTerm = this.value.toLowerCase();
        const filteredNodes = data.nodes.filter(d => d.name.toLowerCase().includes(searchTerm));

        // Clear previous autocomplete results
        autocompleteResults.html("");

        // Hide the results if no matches are found
        if (filteredNodes.length === 0) {
          autocompleteResults.style("display", "none");
          return;
        }

        // Display the filtered nodes in the autocomplete results
        autocompleteResults.style("display", "block");
        filteredNodes.forEach(node => {
          autocompleteResults.append("div")
            .text(node.name)
            .on("click", function() {
              chapterInput.property("value", node.name);
              focusNode(node);
              autocompleteResults.style("display", "none");
            });
        });
      });

      // the chapterInput.on("input") event listener

      chapterInput.on("keydown", function (event) {
        if (event.key === "Enter") {
          const searchTerm = this.value.toLowerCase();
          const matchingNode = data.nodes.find(d => d.name.toLowerCase() === searchTerm);

          if (matchingNode) {
            focusNode(matchingNode);
            autocompleteResults.style("display", "none"); // Hide the autocomplete dropdown
          } else {
            alert("No matching chapter found!"); // Notify the user if no match is found
          }
        }
      });
      // Hide the autocomplete results when clicking outside the input or results
      document.addEventListener("click", function(event) {
        if (!chapterInput.node().contains(event.target) && !autocompleteResults.node().contains(event.target)) {
          autocompleteResults.style("display", "none");
        }
      });

      // Function to focus on a specific node by zooming and highlighting it
      function focusNode(nodeData) {
        const x = nodeData.x;
        const y = nodeData.y;
        const scale = 2; // Adjust the zoom scale as needed

        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(scale)
            .translate(-x, -y)
          );

        setSelectedNode(nodeData, node.select(`circle`).node());
      }
    });
  </script>
</body>
</html>