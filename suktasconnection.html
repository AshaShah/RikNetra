<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Network Graph Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="suktaconnection.css">
</head>

<body>
  <div class="controls">
    <button id="backBtn">Back To Main</button>
    <input type="text" id="search-input" placeholder="Search node...">
    <button id="zoom-in">Zoom In</button>
    <button id="zoom-out">Zoom Out</button>
    <button id="resetBtn">Reset Graph</button>
    <label>
      <input type="checkbox" id="toggle-labels" checked> Show Labels
    </label>
    <label>
      <input type="checkbox" id="isolate-node-toggle"> Show only selected Sukta
    </label>
  </div>

  <div class="graph-container">
    <div class="graph-buttons">
      <button id="colorGroupBtn" class="color-btn">Color by Group</button>
      <button id="defaultColorBtn" class="color-btn">Default Color</button>
      <div id="selectedOption" class="selected-option">Default Color selected</div>
    </div>
    <svg width="100%" height="100%"></svg>
    <div id="tooltip" class="tooltip" style="display: none;"></div>
    <div id="popup" class="popup" style="display: none;">
      <h3 id="popup-title"></h3>
      <ul id="popup-links"></ul>
      <button id="read-chapter">Read this Chapter</button>
    </div>
  </div>

  <script>
const width = 1200;
const height = 800;
let selectedNode = null;
let selectedEdge = null;
let isolateMode = false;

const svg = d3.select("svg");
const tooltip = d3.select("#tooltip");
const popup = d3.select("#popup");
const popupTitle = d3.select("#popup-title");
const popupLinks = d3.select("#popup-links");

const zoom = d3.zoom()
  .scaleExtent([0.1, 5])
  .on("zoom", (event) => {
    g.attr("transform", event.transform);
  });

svg.call(zoom);

const g = svg.append("g");

d3.json("updated_data.json").then(data => {
  const nodes = data.nodes;
  const edges = data.edges;

  // Extract weights from edges for normalization
  const weights = edges.map(d => d.weight);

  // Find the minimum and maximum weights for normalization
  const min_weight = Math.min(...weights);
  const max_weight = Math.max(...weights);

  // Define the new range for normalized weights
  const new_min = 1;
  const new_max = 10;

  edges.forEach(d => {
    if (max_weight === min_weight) {
      d.normalized_weight = new_max; // If all weights are the same, use the maximum value
    } else {
      d.normalized_weight = ((d.weight - min_weight) / (max_weight - min_weight)) * (new_max - new_min) + new_min;
    }
  });


  const xScale = d3.scaleLinear()
    .domain([d3.min(nodes, d => d.x), d3.max(nodes, d => d.x)])
    .range([100, width - 100]);

  const yScale = d3.scaleLinear()
    .domain([d3.min(nodes, d => d.y), d3.max(nodes, d => d.y)])
    .range([100, height - 100]);

  const link = g.append("g")
    .selectAll("line")
    .data(edges)
    .enter()
    .append("line")
    .attr("class", "edge")
    .attr("stroke-width", d => 11 - d.normalized_weight) // Apply normalized weight
    .attr("stroke", "#aaa")
    .on("click", (event, d) => {
      if (selectedEdge) {
        selectedEdge.attr("stroke", "#aaa"); // Reset previous selected edge color
      }
      selectedEdge = d3.select(event.target).attr("stroke", "red").attr("stroke-width", 11 - d.normalized_weight);
      highlightEdgeNodes(d);
    })
    .on("mouseover", (event, d) => {
      d3.select(event.target).attr("stroke", "red").attr("stroke-width", 11 - d.normalized_weight);
    })
    .on("mouseout", (event, d) => {
      if (!selectedEdge || d3.select(event.target).datum() !== selectedEdge.datum()) {
        d3.select(event.target).attr("stroke", "#aaa").attr("stroke-width", 11 - d.normalized_weight);
      }
    });

  // Define the drag behavior
  const drag = d3.drag()
    .on("start", dragStarted)
    .on("drag", dragged)
    .on("end", dragEnded);

  const node = g.append("g")
    .selectAll("circle")
    .data(nodes)
    .enter()
    .append("circle")
    .attr("class", "node")
    .attr("r", 8)
    .attr("fill", "#43a872")
    .call(drag) 
    .on("mouseover", (event, d) => {
      tooltip.style("display", "block")
        .html(`<strong>${d.name}</strong>`)
        .style("left", `${event.pageX + 5}px`)
        .style("top", `${event.pageY + 5}px`);
    })
    .on("mouseout", () => {
      tooltip.style("display", "none");
    })
    .on("click", (event, d) => {
      selectedNode = d;
      showPopup(d);
      zoomToNode(d);
      highlightNode(d);
    });

  const label = g.append("g")
    .selectAll("text")
    .data(nodes)
    .enter()
    .append("text")
    .attr("x", d => xScale(d.x) + 10)
    .attr("y", d => yScale(d.y) + 5)
    .text(d => d.name)
    .style("font-size", "5px")
    .style("fill", "black");

  // Force simulation
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(edges).id(d => d.id).distance(50))
    .force("charge", d3.forceManyBody().strength(-30))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("x", d3.forceX().x(d => xScale(d.x)))
    .force("y", d3.forceY().y(d => yScale(d.y)))
    .on("tick", ticked);

  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);

    label
      .attr("x", d => d.x + 10)
      .attr("y", d => d.y + 5);
  }

  // Drag event handlers
  function dragStarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
    simulation.alpha(0.3).restart();
  }

  function dragEnded(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  d3.select("#toggle-labels").on("change", function () {
    updateVisibility();
  });

  d3.select("#zoom-in").on("click", () => {
    svg.transition().call(zoom.scaleBy, 1.2);
  });

  d3.select("#zoom-out").on("click", () => {
    svg.transition().call(zoom.scaleBy, 0.8);
  });

  d3.select("#search-input").on("input", function () {
    const searchTerm = this.value.toLowerCase();
    const matchingNode = nodes.find(n => n.name.toLowerCase().includes(searchTerm));
    if (matchingNode) {
      selectedNode = matchingNode;
      showPopup(matchingNode);
      zoomToNode(matchingNode);
      highlightNode(matchingNode);
    }
  });

  d3.select("#isolate-node-toggle").on("change", function () {
    isolateMode = this.checked;
    updateVisibility();
  });

  d3.select("#close-popup").on("click", () => {
    popup.style("display", "none");
    isolateMode = false;
    updateVisibility();
  });

  d3.select("#colorGroupBtn").on("click", () => {
    colorNodesByGroup();
  });


  d3.select("#defaultColorBtn").on("click", () => {
    resetNodeColors();
  });

  function showPopup(node) {
  popupTitle.text(`Connections for ${node.name}`);
  popupLinks.html("");

  const connections = edges.filter(e => e.source.id === node.id)
                           .sort((a, b) => a.weight - b.weight); // Sort by weight ascending

  connections.forEach(conn => {
    const targetNode = nodes.find(n => n.id === conn.target.id);
    if (targetNode) {
      popupLinks.append("li")
        .text(`${targetNode.name}`);
    }
  });

  popup.style("display", "block");
}
  function zoomToNode(node) {
    const x = node.x;
    const y = node.y;
    const scale = 2;
    const transform = d3.zoomIdentity
      .translate(width / 2, height / 2)
      .scale(scale)
      .translate(-x, -y);
    svg.transition().duration(750).call(zoom.transform, transform);
  }

  function highlightNode(selectedNode) {
  node.attr("opacity", d => d.id === selectedNode.id || edges.some(e => e.source.id === selectedNode.id && e.target.id === d.id) ? 1 : 0.1)
      .attr("stroke", d => d.id === selectedNode.id ? "red" : null)
      .attr("stroke-width", d => d.id === selectedNode.id ? 2 : null);
  link.attr("opacity", d => d.source.id === selectedNode.id ? 1 : 0.1)
      .attr("stroke", d => d.source.id === selectedNode.id ? "red" : "#aaa");

  label.style("opacity", d => d.id === selectedNode.id || edges.some(e => e.source.id === selectedNode.id && e.target.id === d.id) ? 1 : 0.1);
}

function highlightEdgeNodes(edge) {
  node.attr("fill", d => {
    if (d.id === edge.source.id) return "blue";
    if (d.id === edge.target.id && edge.source.id !== d.id) return "green";
    return "grey";
  });
}

function updateVisibility() {
  const showLabels = d3.select("#toggle-labels").property("checked");

  node.attr("opacity", d => {
    if (!isolateMode) return 1;
    
    const isConnected = edges.some(e =>
      e.source.id === selectedNode.id && e.target.id === d.id
    );
    
    return d.id === selectedNode.id || isConnected ? 1 : 0;
  });

  link.attr("opacity", d => {
    if (!isolateMode) return 1;
    return d.source.id === selectedNode.id ? 1 : 0;
  });

  label.style("display", d => {
    if (!showLabels) return "none";
    if (!isolateMode) return "block";
    
    const isConnected = edges.some(e =>
      e.source.id === selectedNode.id && e.target.id === d.id
    );
    
    return d.id === selectedNode.id || isConnected ? "block" : "none";
  })
  .style("opacity", d => {
    if (!isolateMode) return 1;
    
    const isConnected = edges.some(e =>
      e.source.id === selectedNode.id && e.target.id === d.id
    );
    
    return d.id === selectedNode.id || isConnected ? 1 : 0.1;
  });
}
function colorNodesByGroup() {
    const customColors = [
      "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf",
      "#aec7e8", "#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5",
      "#393b79", "#637939", "#8c6d31", "#843c39", "#7b4173", "#5254a3", "#8ca252", "#bd9e39", "#ad494a", "#a55194",
      "#6b6ecf", "#b5cf6b", "#e7ba52", "#d6616b", "#ce6dbd", "#9c9ede", "#cedb9c", "#e7cb94", "#e7969c", "#de9ed6",
      "#3182bd", "#31a354", "#756bb1"
    ];
    const colorScale = d3.scaleOrdinal(customColors);

    // Check if group values exist
    nodes.forEach(node => {
      if (node.group === undefined || node.group === null) {
        console.error(`Node ${node.id} is missing group value`);
      } else {
        console.log(`Node ${node.id} belongs to group ${node.group}`);
      }
    });

    // Color the nodes based on their group
    node.attr("fill", d => {
      if (d.group !== undefined && d.group !== null) {
        return colorScale(d.group);
      } else {
        return "#43a872"; // Default color for nodes without a group
      }
    });
  }


  function resetNodeColors() {
    node.attr("fill", "#43a872");
  }

  document.getElementById("backBtn").addEventListener("click", () => {
    window.location.href = "index.html";
  });

  document.getElementById("resetBtn").addEventListener("click", () => {
    location.reload(); // Refresh the page to reset everything to default state
  });
  document.getElementById("colorGroupBtn").addEventListener("click", () => {
      document.getElementById("colorGroupBtn").classList.add("selected");
      document.getElementById("defaultColorBtn").classList.remove("selected");
      document.getElementById("selectedOption").innerText = "Color by Group selected";
      colorNodesByGroup();
    });

    document.getElementById("defaultColorBtn").addEventListener("click", () => {
      document.getElementById("defaultColorBtn").classList.add("selected");
      document.getElementById("colorGroupBtn").classList.remove("selected");
      document.getElementById("selectedOption").innerText = "Default Color selected";
      resetNodeColors();
    });
  d3.select("#read-chapter").on("click", () => {
    if (selectedNode) {
      const chapterName = selectedNode.name;
      const chapterId = selectedNode.id;

      window.location.href = `chapter.html?chapterId=${encodeURIComponent(chapterId)}&chapterName=${encodeURIComponent(chapterName)}`;
    } else {
      alert("Please select a node first.");
    }
  });
});
  </script>
</body>

</html>